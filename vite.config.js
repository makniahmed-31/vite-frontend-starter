import { defineConfig } from 'vite';
import vituum from 'vituum';
import twig from '@vituum/vite-plugin-twig';
import viteImagemin from 'vite-plugin-imagemin';
import { ViteMinifyPlugin } from 'vite-plugin-minify';
import fs from 'node:fs';
import path from 'node:path';
import packageData from './package.json';

const isDocs = process.argv.includes('--docs');

export default defineConfig({
  resolve: {
    alias: {
      '@': path.resolve(process.cwd(), 'src'),
    },
  },
  plugins: [
    vituum({
      pages: {
        dir: './src/view',
      },
      imports: {
        paths: ['./src/scss/*/**', './src/js/*/**'],
        filenamePattern: { '+.css': 'src/scss', '+.js': 'src/js' },
      },
    }),
    twig({
      root: './src',
      globals: getTwigGlobals(),
    }),
    viteImagemin({
      gifsicle: {
        optimizationLevel: 1,
        interlaced: false,
      },
      optipng: {
        optimizationLevel: 5,
      },
      mozjpeg: {
        quality: 75, progressive: true,
      },
      pngquant: {
        quality: [0.7, 0.9],
        speed: 7,
      },
      svgo: {
        plugins: [
          { removeViewBox: false },
          { convertShapeToPath: false },
          { convertEllipseToCircle: false },
        ],
      },
    }),
    ViteMinifyPlugin({
      collapseWhitespace: true,
      includeAutoGeneratedTags: false,
      minifyCSS: true,
      minifyJS: true,
      removeComments: true,
    }),
    htmlHandleDocsBase(),
  ],
  base: isDocs ? `/${packageData.name}/` : '/',
  build: {
    outDir: isDocs ? './docs' : './dist',
    emptyOutDir: true,
    assetsInlineLimit: 0,
    modulePreload: false,
    rollupOptions: {
      input: [
        './src/view/**/*.{twig,html}',
        './src/js/*.js',
      ],
      output: {
        entryFileNames: 'js/[hash].js',
        chunkFileNames: 'js/[hash].js',
        assetFileNames: (assetInfo) => {
          let extType = assetInfo.name.split('.').pop();

          if (/jpe?g|png|svg|gif|webp|ico/i.test(extType)) {
            extType = 'img';
          }

          if (/woff?2|ttf|eot/i.test(extType)) {
            extType = 'font';
          }

          return `${extType}/[hash][extname]`;
        },
      },
    },
  },
});

function getTwigGlobals() {
  const data = {
    APP_NAME: packageData.name,
    APP_NAME_FORMATTED: packageData.name.replace(/[^a-z]+/gi, ' ').replace(/(^\w|\s\w)/g, (m) => m.toUpperCase()),
    APP_VERSION: packageData.version,
    APP_AUTHOR: packageData.author,
    APP_REPOSITORY: packageData.repository?.url,
    APP_DESCRIPTION: packageData.description,
    APP_KEYWORDS: packageData.keywords,
  };

  const dataFolder = path.join(process.cwd(), 'src', 'data');
  const dataFiles = fs.readdirSync(dataFolder).filter((file) => file.endsWith('.json')) || [];

  dataFiles.forEach((file) => {
    const filePath = path.join(process.cwd(), 'src', 'data', file);
    const fileContent = fs.readFileSync(filePath, 'utf8') || '{}';
    const fileData = JSON.parse(fileContent);
    const fileName = file.replace('.json', '').replace(/[\s-]+/g, '_').replace(/[^a-z_]+/g, '').replace(/(_)./g, (s) => s.slice(-1).toUpperCase());

    data[fileName] = fileData;
  });

  return data;
}

function htmlHandleDocsBase() {
  if (!isDocs) {
    return false;
  }

  return {
    name: 'html-transform',
    transformIndexHtml: (html) => {
      const docsBase = `/${packageData.name}`;

      const modifiedHtml = html.replace(/<a\s+([^>]*href=["']([^"']+)["'][^>]*)>/g, (match, attributes) => {
        const hrefMatch = attributes.match(/href=["']([^"']+)["']/);

        if (!hrefMatch) {
          return match;
        }

        const originalHref = hrefMatch[1];

        if (originalHref.startsWith(docsBase)) {
          return match;
        }

        return `<a ${attributes.replace(hrefMatch[0], `href="${docsBase}${originalHref}"`)}>`;
      });

      return modifiedHtml;
    },
  };
}
